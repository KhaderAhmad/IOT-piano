/***************************************************************************************************************************************************/
/*                                                    includes and defines                                                                         */
/***************************************************************************************************************************************************/

#include <WiFi.h>
#include <HTTPClient.h>
#include <Wire.h>
#include <Arduino.h>
#include <string.h>
#include "Adafruit_MPR121.h"
#include <Adafruit_NeoPixel.h>
#include "driver/i2s.h"
#include <math.h>

// Defines
#define I2S_WS 25   // LRC pin
#define I2S_SD 23   // DIN pin
#define I2S_SCK 26  // BCLK pin
#define SAMPLE_RATE 44100

// Which pin on the Arduino is connected to the NeoPixels?
#define Neo_pin 18  // On Trinket or Gemma, suggest changing this to 1
//red for 3v3
//white for gnd
//green for 18

// How many NeoPixels are attached to the Arduino?
#define NUMPIXELS 11  // Popular NeoPixel ring size


#ifndef _BV
#define _BV(bit) (1 << (bit))
#endif

#ifdef __AVR__
#include <avr/power.h>  // Required for 16 MHz Adafruit Trinket
#endif

// VCC: Connect to 3.3V on the ESP32.
// GND: Connect to GND on the ESP32.
// SDA: Connect to GPIO 21 (I2C data line) on the ESP32.
// SCL: Connect to GPIO 22 (I2C clock line) on the ESP32.
// IRQ: Not necessary for basic functionality but can be connected to an interrupt pin on the ESP32 if needed for advanced features.



/***************************************************************************************************************************************************/
/*                                                         WIFI CONNECTION                                                                         */
/***************************************************************************************************************************************************/

// WiFi and Firebase setup
#include <ESP32Firebase.h>
#define _SSID "jamila"        // Your WiFi SSID
#define _PASSWORD "12345678"  // Your WiFi Password
#define REFERENCE_URL "https://ass2-cb1cb-default-rtdb.firebaseio.com/"
#define FIREBASE_AUTH "AIzaSyB1GPXvfeC1zr0cQ_-go7AmLtPTyiZrPR0"

Firebase firebase(REFERENCE_URL);

void firebaseSetup() {
  // Serial.println("Connecting to WIFI: Pending...");
  // WiFi.mode(WIFI_STA);
  // WiFi.disconnect();
  // delay(1000);
  // WiFi.begin(_SSID, _PASSWORD);

  //  while (WiFi.status() != WL_CONNECTED) {
  //   freeplay();
  //  delay(10);
  // Serial.print("-");
  // }
  // Serial.println("Connected to WIFI");
}


String firebaseReadSong() {
  String songStr = "/currentSong";

  String song = firebase.getString(songStr);
  Serial.print("Song is:");
  Serial.println(songStr);
  return songStr;
}


String firebaseReadSongDuration() {
  String durStr = "/currentSongDuration";
  String song = firebase.getString(durStr);
  Serial.print("duration is:");
  Serial.println(durStr);
  return durStr;
}



/***************************************************************************************************************************************************/
/*                                                           MPR121 setup                                                                          */
/***************************************************************************************************************************************************/


// MPR121 setup
Adafruit_MPR121 cap = Adafruit_MPR121();
uint16_t lasttouched = 0;
uint16_t currtouched = 0;

void mprSetup() {
  Serial.println("Adafruit MPR121 Capacitive Touch sensor test");
  if (!cap.begin(0x5A)) {
    Serial.println("MPR121 not found, check wiring?");
    while (1)
      ;
  }
  Serial.println("MPR121 found!");
}



/***************************************************************************************************************************************************/
/*                                                         Neo_PIXEL Setup                                                                         */
/***************************************************************************************************************************************************/


Adafruit_NeoPixel pixels(NUMPIXELS, Neo_pin, NEO_GRB + NEO_KHZ800);

void Neo_setup() {
  Serial.println("aetiing neo_pixel");
}

/***************************************************************************************************************************************************/
/*                                                           light functions                                                                       */
/***************************************************************************************************************************************************/

void lightByNum(int led_num) {

  if (led_num < 0) {
    pixels.clear();  // Set all pixel colors to 'off'
  } else {
    pixels.setPixelColor(led_num, pixels.Color(150, 0, 0));
  }
}

void turnOffByNum(int led_num) {

  if (led_num < 0) {
    pixels.clear();  // Set all pixel colors to 'off'
  } else {
    pixels.setPixelColor(led_num, pixels.Color(0, 150,0));
  }
}

void lightByChar(char note) {
  int led_num = getNumForChar(note);
  if (led_num < 0) {
    pixels.clear();  // Set all pixel colors to 'off'
  } else {
    pixels.setPixelColor(led_num, pixels.Color(150, 0, 0));
  }
}



/***************************************************************************************************************************************************/
/*                                                         DAC Amplifier setup                                                                     */
/***************************************************************************************************************************************************/

// DAC Amplifier setup
size_t bytes_written;
const int sample_count = 256;  // Adjust sample count if needed
//int16_t samples[sample_count];
//int16_t* samples;

#define AT 261.63
#define BT 293.66
#define CT 329.63
#define DT 349.23
#define ET 392.00
#define FT 440.00
#define GT 493.88
#define HT 523.25
#define NO 0
#define I2S_PORT I2S_NUM_0


void dacSetup() {
  // I2S configuration
  i2s_config_t i2s_config = {
    .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_TX),
    .sample_rate = SAMPLE_RATE,
    .bits_per_sample = I2S_BITS_PER_SAMPLE_16BIT,
    .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,
    .communication_format = I2S_COMM_FORMAT_I2S_MSB,
    .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
    .dma_buf_count = 8,
    .dma_buf_len = 64,
    .use_apll = false,
    .tx_desc_auto_clear = true,
    .fixed_mclk = 0
  };

  // I2S pin configuration
  i2s_pin_config_t pin_config = {
    .bck_io_num = 26,    // Bit Clock (BCK)
    .ws_io_num = 25,     // Word Select (WS)
    .data_out_num = 23,  // Data Out (DOUT)
    .data_in_num = I2S_PIN_NO_CHANGE
  };

  // Install and start I2S driver
  i2s_driver_install(I2S_PORT, &i2s_config, 0, NULL);
  i2s_set_pin(I2S_PORT, &pin_config);
  i2s_zero_dma_buffer(I2S_PORT);
}


/***************************************************************************************************************************************************/
/*                                                           sound functions                                                                       */
/***************************************************************************************************************************************************/


void playTone(float frequency) {
  const int sampleCount = SAMPLE_RATE / frequency;
  int16_t samples[sampleCount];
  for (int i = 0; i < sampleCount; i++) {
    float sample = sin(2 * PI * frequency * i / SAMPLE_RATE);
    samples[i] = (int16_t)(sample * 32767);
  }
  size_t bytesWritten;
  for (int i = 0; i < (SAMPLE_RATE / sampleCount) / 4; i++) {
    i2s_write(I2S_PORT, samples, sampleCount * sizeof(int16_t), &bytesWritten, portMAX_DELAY);
  }
}


float getFreqForChar(char note)
{
   float freq = 0.0;
  switch (note) {
    case 'A': freq = AT; break;  // Do
    case 'B': freq = BT; break;  // Re
    case 'C': freq = CT; break;  // Mi
    case 'D': freq = DT; break;  // Fa
    case 'E': freq = ET; break;  // Sol
    case 'F': freq = FT; break;  // La
    case 'G': freq = GT; break;  // Ti
    case 'H': freq = HT; break;  // Do (higher octave)
    default: freq = NO; break;   // Silence
  }
return freq;
}

int getNumForChar(char note) {
  switch (note) {
    case 'A': return 0;
    case 'B': return 1;
    case 'C': return 2;
    case 'D': return 3;
    case 'E': return 4;
    case 'F': return 5;
    case 'G': return 6;
    case 'H': return 7;
    default: return -1;
  }
}



void playSoundByChar(char note) {
  float freq = getFreqForChar(note);

  // const int sampleCount = int(SAMPLE_RATE / freq);
  // int16_t samplesS[sampleCount];

  // for (int i = 0; i < sampleCount; i++) {
  //   float sample = sin(2 * PI * freq * i / SAMPLE_RATE);
  //   samplesS[i] = (int16_t)(sample * 32767);
  // }

  // size_t bytesWritten;
  // for (int i = 0; i < SAMPLE_RATE / sampleCount; i++) {
  //   i2s_write(I2S_PORT, samplesS, sampleCount * sizeof(int16_t), &bytesWritten, portMAX_DELAY);
  // }
}



void playSongByNum() {
  bool correct = true;
  String song = "A,B,C,D";
  String dur = "5000,1000,5000,1000";
  //String song = firebaseReadSong();
 // String dur = firebaseReadSongDuration();
  int num = 0;
  String strduration = "";
  for (int i = 0; i < song.length(); i++) {
    strduration = "";
    char note = song[i];

    if (note == ',') continue;
    Serial.println(song[i]);
    while (dur[num] != ',' && dur[num]!= NULL) {
      Serial.println("in while");
      strduration += dur[num];
      num++;
    }
    num++;
   int Notedur = strduration.toInt();

    lightByChar(note);  //// trun on
    pixels.show();
    playSoundByChar(note);
    char next = (i>=(song.length()-1)) ? (-1) : (song[i+2]);
    unsigned long startMillis = millis();
    correct = waitForTouchAndCheckIfCorrect(song[i], next, Notedur);
    // if(millis() - long(Notedur+startMillis) >= (long)10000){
    //   correct = false;
    // }
    pixels.clear();
    pixels.show();
    if (!correct) {
      return;
    }
  }
}

bool waitForTouchAndCheckIfCorrect(char note, char next, uint16_t dur) {
  Serial.print("waiting for correct touch with note ");
  Serial.print(note);
  Serial.print(" and next ");
  Serial.print(next);
  Serial.print(" and duration ");
  Serial.println(dur);

  currtouched = cap.touched();
  while (!currtouched) {
    delay(100);
    pixels.show();
    currtouched = cap.touched();
  }
  for (uint8_t i = 0; i < 12; i++) {
    if ((currtouched & _BV(i)) && !(lasttouched & _BV(i))) {
      Serial.print(i);
      Serial.println(" touched");
      int correctNote = getNumForChar(note);
      while_touched_play_sound_for_learning(i, next, dur, correctNote);
      if (i != correctNote) {
        Serial.println("Incorrect note");
        return false;
      }
    }
  }
  lasttouched = currtouched;
  Serial.println("Correct note");
  return true;
}


void while_touched_play_sound_for_learning(uint8_t i, char next, uint16_t dur, int correctNote) {
  unsigned long startMillis = millis();
  while (((cap.touched()) & _BV(i)) ) {
    unsigned long curMillis = millis() - startMillis;
    if(curMillis >= dur){
      Serial.println("oooh in if baby");
      turnOffByNum(i);
      lightByNum(next);
    }else{
      if(i == correctNote){
      lightByNum(i);
            Serial.println("NOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO in if baby");
      }else{
        turnOffByNum(i);
      }

    }
          Serial.println(curMillis);

    pixels.show();
    switch (i) {
      case 0: playTone(261.63); break;  //DO
      case 1: playTone(293.66); break;  //RE
      case 2: playTone(329.63); break;  //MI
      case 3: playTone(349.23); break;  //FA
      case 4: playTone(392.00); break;  //SOL
      case 5: playTone(440.00); break;  //LA
      case 6: playTone(493.88); break;  //SI
      case 7: playTone(523.25); break;  // Do (higher octave)
      case 8: playTone(552.37); break;
      case 9: playTone(581.55); break;
      default: playTone(0.0); break;
    }
  }
}

/***************************************************************************************************************************************************/
/*                                                           freeplay functions                                                                       */
/***************************************************************************************************************************************************/

void while_touched_play_sound_for_freeplay(uint8_t i) {
  while (((cap.touched()) & _BV(i))) {
    lightByNum(i);
    pixels.show();
    switch (i) {
      case 0: playTone(261.63); break;  //DO
      case 1: playTone(293.66); break;  //RE
      case 2: playTone(329.63); break;  //MI
      case 3: playTone(349.23); break;  //FA
      case 4: playTone(392.00); break;  //SOL
      case 5: playTone(440.00); break;  //LA
      case 6: playTone(493.88); break;  //SI
      case 7: playTone(523.25); break;  // Do (higher octave)
      case 8: playTone(552.37); break;
      case 9: playTone(581.55); break;
      default: playTone(0.0); break;
    }
  }
}
void freeplay() {
  //Serial.println("in freeplay");
  // Get the currently touched pads
  currtouched = cap.touched();

  for (uint8_t i = 0; i < 12; i++) {
    // it if is touched and wasnt touched before, alert!
    if ((currtouched & _BV(i)) && !(lasttouched & _BV(i))) {
      Serial.print(i);
      Serial.println(" touched");
      while_touched_play_sound_for_freeplay(i);
    }
    if (!(currtouched & _BV(i)) && (lasttouched & _BV(i))) {
      Serial.print(i);
      Serial.println(" released");
      lightByNum(-1);
    }
    pixels.show();
  }
  lasttouched = currtouched;
  return;
}

// void learning(int songnum) {
//   playSongByNum(songnum);
// }


/***************************************************************************************************************************************************/
/*                                                              setup                                                                              */
/***************************************************************************************************************************************************/
void setup() {
  Serial.begin(115200);
  while (!Serial) { delay(10); }
  mprSetup();
  delay(1000);
  dacSetup();
  delay(1000);
  Neo_setup();
  //   #if defined(__AVR_ATtiny85__) && (F_CPU == 16000000)
  // clock_prescale_set(clock_div_1);
  // #endif
  pixels.begin();
  delay(1000);
  firebaseSetup();
}



/***************************************************************************************************************************************************/
/*                                                                loop                                                                             */
/***************************************************************************************************************************************************/


void loop() {

  playSongByNum();
 //freeplay();
 // pixels.show();
}
